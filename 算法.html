<!--
 * @Author: your name
 * @Date: 2020-08-12 15:55:46
 * @LastEditTime: 2020-08-14 14:19:59
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \网易高级前端课程\1JS\算法.html
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /**
       * 冒泡排序
       *
       * 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，
       * 一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行
       * 直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的
       * 元素会经由交换慢慢"浮"到数列的顶端。
       *
       * 可以参考：https://www.runoob.com/w3cnote/bubble-sort.html
       */
      let arr = [3, 4, 2, 1, 9, 10, 5, 8, 12, 16, 14, 21];
      function bubbleSort(arg) {
        let arr = [...arg];
        for (let i = 0; i < arr.length - 1; i++) {
          //从后往前确定，最大值，第一次遍历就可以确定
          for (let j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
              [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
          }
        }
        return arr;
      }

      //console.log(bubbleSort(arr));
      /**
       * 插入排序
       *
       * 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易
       * 理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，
       * 它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
       *
       * 可以参考：https://www.runoob.com/w3cnote/insertion-sort.html
       */
      function insertionSort(src) {
        let arr = [...src];
        for (let i = 0; i < arr.length - 1; i++) {
          for (let j = i; j >= 0; j--) {
            if (arr[j] > arr[j + 1]) {
              [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            } else {
              break; //如果 arr[j] < arr[j + 1]  那么arr[j]前面的都比arr[j+1]小，没必要接着遍历
            }
          }
        }
        return arr;
      }
      //console.log(insertionSort(arr));

      //快速排序
      const arr1 = [3, 0, 1, 4, 6, 7, 2, 5, 10];
      function quicksort(arr, left, right) {
        if (left > right) return;
        let i = typeof left === "number" ? left : 0;
        let j = typeof right === "number" ? right : arr.length - 1;
        let temp = arr[left];
        while (i !== j && i < j) {
          while (i < j && arr[j] >= temp) {
            j--;
          }
          while (i < j && arr[i] <= temp) {
            i++;
          }
          // console.log(i, j);
          if (i < j) {
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          //console.log(arr);
        }
        [arr[left], arr[j]] = [arr[j], arr[left]];
        quicksort(arr1, left, i - 1);
        quicksort(arr1, j + 1, right);
      }
      //quicksort(arr1, 0, arr1.length - 1);

      //归并排序
      const arr2 = [2, 5, 3, 1, 4];
      function mergeSort(arr) {
        console.log(arr,'arr')
        if (arr.length < 2) return arr;
        let mid = Math.floor(arr.length / 2);
        let left = arr.slice(0, mid);
        let right = arr.slice(mid);

        return merge(mergeSort(left), mergeSort(right));
      }

      function merge(left, right) {
        console.log(left, right,'leftright');
        let result = [];

        while (left.length && right.length) {
          if (left[0] <= right[0]) {
            result.push(left.shift());
          } else {
            result.push(right.shift());
          }
        }
        while (left.length) {
          result.push(left.shift());
        }
        while (right.length) {
          result.push(right.shift());
        }
        console.log(result,'result');
        return result;
      }
      //console.log(mergeSort(arr2));
    </script>
  </body>
</html>
