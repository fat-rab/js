<!--
 * @Author: your name
 * @Date: 2020-11-09 14:53:34
 * @LastEditTime: 2020-11-20 13:44:09
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \js\08类型进阶.html
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //类型转换
      //隐式类型转换
      //数字和字符串+操作时，数字隐式转换成字符串 其他运算符字符串会隐式地转化成字数字
      //数字,字符串进行 '.'操作时，会装换成对象类型
      //在'+'运算中 []会转换成 '',[1]会转换成'1'
      //undefined转化成Number时结果为NaN
      //null转化成Number时结果为0
      //""转化成Boolean时结果为false
      //带有非数字字符的字符串转成Number是结果都为NaN
      //NaN转成Boolean时结果为false
      //所有对象转成boolean结果都是true
      //所有对象转成Number结果都是NaN
      // console.log("5" - "2"); //3 number
      // console.log("" - 1); //-1 number
      // console.log(true + false); //1 number
      // console.log(null + 1); //1 number
      // console.log(undefined + 1); //NAN
      // console.log([] + []); //'' string
      // console.log([1] + [2]); //'12' string
      // console.log({} + 1); // [object Object]1 string
      // console.log(5-2 + "a"); //3a
      // //转字符串场景
      // console.log(1 + "px");
      // //转数值场景 会进行数学运算
      // console.log(+"abc"); //NAN
      // console.log(+" 123"); //123 number
      // //转布尔 ，通常出现在if语句，逻辑运算中
      // let s = "123";
      // if (s) {
      //   //true
      //   console.log(123);
      // }
      // if ("") {
      //   //false
      //   console.log("asdf");
      // }
      // console.log(!!s); //ture

      //类型转换场景 ：相等性
      // == 运算符会有类型转换，===不会
      //隐式转换就是系统默认的、不需要加以声明就可以进行的转换
      //要比较相等性之前，不能将 null 和 undefined 转换成其他任何值，并且规定null 和 undefined 是相等的。
      //全等于状态下，是false，这个很好理解了。它们不属于同一数据类型。 null=>object undefined=>undefined
      //console.log(null == undefined, "0" == 0, 0 == false, "0" == false); //true

      //显示类型转换 利用强制类型转换运算符进行转换，这种强制转换过程称为显式转换。
      //显示类型转换，可以是代码变得清晰易读，推荐在实际编码中使用，最贱的方法就是使用Boolean() Number() String() Object()
      //console.log(Object(3)) //等价 new Number(3)  //Number {3}
      //toString()和string() 通常结果一致，，number类型的toString()方法支持第二个参数，指定要转换的进制
      //null 和undefined 没有toString 方法，会报错
      //console.log(typeof(3.123.toFixed(2)))  //number会转换成string

      //类型判断
      //1 instanceof 无法识别原始数据类型  虽然typeof(null) 是object 但是null 并不是object的实例
      // console.log(
      //   null instanceof Object,
      //   [] instanceof Array,
      //   [] instanceof Object
      // ); //false true true

      //2 constructor 可以检测变量的构造函数 也可以检测自定义的类型  null和undefined 没有这个方法，会报错
      // console.log({ x: 1 }.constructor.name, [].constructor.name); //Object Array
      // function Foo() {}
      // console.log(new Foo().constructor.name); //Foo

      //3 Object.prototype.toString.call(obj)  检测对象的内部属性 [[Class ]] 不可以检测自定义的类型
    </script>
  </body>
</html>
