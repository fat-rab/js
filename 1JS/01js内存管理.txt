基础数据类型保存在栈内存中, 函数调用就会入栈， https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack
引用数据类型保存在堆内存中
函数也属于引用类型，

垃圾回收
找到不再继续使用的变量，释放其占用的内存，垃圾回收器会周期性的执行这一操作
优势：简化内存管理代码，降低程序员负担，避免长时间运行造成的内存泄露
劣势：js没有包含任何和内存有关的API，无法干预内存回收

V8引擎
限制内存的原因：最初为浏览器设置，不太需要用到大量内存的情况
防止垃圾回收的时候，暂停执行JS的时间过长

V8将堆内存分为新生代和老生代
64位 新生代为32MB ，分为from 和to 两块，
from为正在使用的空间， to 为闲置空间
内存回收时，from空间中还在使用的变量会复制一份到to中，失去引用的会删除，然后使用Scavenge算法
对to 进行整顿，最后from 和to的身份会换过来，
Scavenge算法缺点：只能使用一半内存空间，但是因为新生代变量生命周期短，所以很适合。
新生代中的变量如果经历过多次内存回收还没有被回收，或者已经经历过一次scavenge算法，或者to 空间占用超过
25%，就会晋升到老生代。
老生代使用标记清除
标记清除：变量进入环境会标记“进入环境”，离开环境会标记“离开环境”。垃圾回收器会在运行的时候给存储在内存中的所有变量都加上标记，
然后回去表环境中的变量和被环境中变量引用的变量的标记，最后垃圾回收器会销毁仍然带标记的值，并且回收它们所占用的内存。

引用计数的含义是跟踪记录每个值被引用的次数。垃圾回收的时候，会清除每个引用次数为零的变量，但是无法回收循环引用所占用的内存。

由于JS是单线程，如果回收任务非常繁重，会严重阻碍JS进程，这时候V8采用增量标记的方法，回收一会儿，执行
一会儿，如此循环直到回收完毕